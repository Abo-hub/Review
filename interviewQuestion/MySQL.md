# MySQL

## 1. SQL的select语句完整的执行顺序
1. form 子句组装来子不同数据的数据源
2. where 子句基于指定的条件对记录进行筛选
3. group by子句将数据划分为多个分组
4. 使用聚集函数进行计算
5. 使用havaing子句筛选分组
6. 计算所有表达式
7. select 的字段
8. 使用order by对结果进行排序

## 2. SQL之聚合函数
聚合函数是对一组值进行计算并返回单一的值的函数，他经常与select语句中的group by子句一同使用
a.avg(): 返回的是指定组中的平均值，空值被忽略
b.count(): 返回的是指定组中的项目个数
c.max(): 返回指定数据中的最大值
d.min(): 返回指定数据中的最小值
e.sum(): 返回指定数据的和，只能用于数字列，空值忽略
f.group by(): 对数据进行分组，对执行完group by之后的组进行聚合函数的运算，计算每一组的值。最后用having去掉不符合条件的组，having子句中的每一个元素必须出现在select列表中

## 3. SQL之连接查询(左连接和右连接的区别)
- 外连接:
    - 左连接(左外连接)：以左表作为基准进行查询，左表数据会全部显示出来，右表如果和左表匹配的数据则显示相应的数据，如果不匹配则显示为null
    - 右连接(右外连接)：以右表作为基准进行查询，右表数据会全部显示出来，左表如果和右表匹配的数据则小时相应的字段的数据，如果不匹配则显示为null
    - 全连接：先以左表进行左外连接，再以右表进行右外连接
- 内连接：显示表之间有连接匹配的所有行

## 4. MySQL性能优化
### 4.1 当只要一行数据时使用limit 1
查询时如果已知会得到一条数据，这种情况加上limit 1 会增加性能。因为mysql数据库引擎会再找到一条结果停止搜索，而不是继续查询下一条是否符合标准直到所有记录查询完毕。

### 4.2 选择正确的数据库引擎
MySQL中有两个MyISAM和InnoDB，每个引擎有利有弊
- MyISAM适用于一些大量查询的应用，但对于大量写功能的应用不是很好。甚至你只需要update一个子u但整个表都会被锁起来。而别的进程就算是读操作也不行，要等到当前update操作完成之后才能继续。另外MyISAM对于select count(*)这类操作是超级快的。
- InnoDB的趋势会是一个非常负载的存储引擎，对于一些小的应用MyISAM还慢，但是支持`行锁`，所以再写操作比较多的时候会比较优秀。并且，它支持很多的高级应用，例如：事务。

### 4.3 用not exist 代替not in
 
### 4.4 对操作符的优化，尽量不采用不利于索引的操作符
如: in  not in  is full  is not full  <> 等
某个子字段总要拿来搜索，，为其建立索引：
MySQL中可以利用alter table 语句来为表中的字段添加索引，语法为：alter table 表明为 add index(字段名)；

## 5 MySQL数据库架构

### 存储引擎
1. InnoDB存储引擎
    - 默认事务引擎，最重要最广泛的存储引擎，性能非常优秀
    - 数据存储在共享表空间，可以通过配置分开。也就是多个表和索引都存储在一个表空间中，可以通过配置文件改变此配置
    - 对主键查询的性能高于其他类型的存储引擎
    - 内部做了很多优化，从磁盘读取数据时会自动构建hash索引，插入数据时自动构建插入缓冲区
    - 支持崩溃后的安全恢复
    - 支持行级锁
    - 支持外键


## 索引相关

### 1. 什么是索引？
索引是一种数据结构，可以帮助我们快速的进行数据的查找。

### 2. 索引是个什么样的数据结构？
索引的数据结构和具体存储引擎相关，在MySQL中使用较多的索引有Hash索引，B+数索引等。而我们经常使用的InnoDB存储引擎默认索尼因实现为B+树索引

### 3. Hash索引和B+树索引有什么区别或者说优劣？
- Hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获得相应的键值，之后进行回表查询获得实际数据。
- B+树索引底层是现实`多路平衡查找树`，对于每一次的查询都是从根节点除法，查找到叶子节点就可以获得到所查键值，然后根据铲鲟判断是否需要徽标查询数据。

#### 不同
- hash索引进行等值查询更快(一般情况下),但是无法进行范围查询
因为hash索引经过hash函数建立索引后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的所有系欸但皆遵循(左节点小于父节点，右节点大于父节点)天然支持范围
- hash索引并不支持使用索引进行排序，原理同上
- hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测，AAAA和AAAB的索引没有相关性。
- hash索引任何时候避免不了回表查询，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询
- hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差，而B+树的查询效率可能比较稳定，对于所有的查询都是从根节点到叶子几点，且 树的高度较低。

> 一次，在大都数情况下，直接选择B+树索引可以获得稳定较好的查询速度，而不需要使用hash索引

### 4.  什么是聚簇索引？
在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引，在InnoDB中，只有主键是索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引。

当查询使用聚簇索引时，对应用的而叶子节点，可以获得整行数据，因此不用再次进行回表查询。

### 5. 非聚簇索引一定会回表查询吗？
不一定，这涉及到查询语句所需要的字段是否全部命中了所以，如果全部命中索引你，那么就不必再进行回表查询

举个简单的例子，假如我们在员工表的年龄建立了索引，那么当进行`select age from employee where age < 20`的查询时，在索引的叶子节点上，已经报了age信息，不会再次进行回表查询。

### 6. 在建立索引的时候，需要哪些考虑的因素呢？ ★
建立索引的时候一般要考虑到字段的使用频率，经常作为条件进行查询的字段比较适合，如果需要建立联合索引的话，还要考虑联合索引中的顺序，此外也要考虑其他方面，比如防止过多的所有索引对表造成太大的压力，这些都和实际的表结构记忆拆线呢方式有关。

### 7. 联合索引是什么？为什么需要注意联合索引中的顺序？ ★
MySQL可以使用多个字段同时建立一个索引，叫做联合索引，在联合索引中，如果想要名中索引，需要按照建立索引时的字段顺序遍历挨个使用，否则无法名中索引。

#### 原因 ★
MySQL使用索引时需要索引有序，假设现在建立了"name,age,scholl"的联合索引，那么索引的排序为：先按照name排序，如果name相同，则按照age排序，如果age也相同，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age子u但用作索引查找，...以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求平凡或者字段选择性搞的列放前面，此外可以根据特例的查询或者表结构进行单独的调整。

### 8. 创建的索引有没有被使用到？或者说怎么才可以直到这条语句运行很慢的原因？
MySQL提供了explain命令来查查看语句的执行计划，MySQL在某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息，可以通过其中和索引有关的信息分析是否名中了索引。

### 9. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢？
- 使用了不等于查询
- 列参与了数学运算或者函数
- 在字符串like时左边是通配符，类似于'%aaa'.
- 当mysql分析全表扫描比使用索引快的时候不会使用索引。
- 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引


## 事务
### 1. 什么是事务？
(转账的例子) 事务是一系列的操作，它们要符合ACID特性，最常见的理解就是：食物中的操作要么全部成功，要么全部失败。

### 2. ACID是什么？可以详细说一下吗？
- A(Atomicity)：原子性，就是要么全部成功，也要么全部失败，不可能只执行一部分操作
- C(Consistency)：一致性，系统总是从一个一致性的状态转移到另一个一致性的状态，不会存在中间状态
- I(Isolation)：隔离性，通常来说，一个事务在完全提交之前，对其他事务是不可见的。(特例，比如最低隔离级别`READ UNCOMMITTED`对其他事务的可见就造成了`脏读`的出现)
- D(Durability)：持久性，一旦事务提交，那么就永远是这个样子了，哪怕系统崩溃也不会影响到这个事务的结果。

### 3. 同时有多个事务在进行会怎么样？
多事务的并发进行一般会造成一下几个问题：
- 脏读：A事务读到了B事务未提交的内容，而B事务后面进行了回滚
- 不可重复读：当设置A事务只能读取B事务已经提交的部分，会造成A事务内的两次查询，结果竟然不一样，因为在此期间B事务进行了提交操作。
- 幻读：A事务读取了一个范围的内容，而同时B事务在此期间插入了一条数据造成“幻读”

### 4. 怎么解决这些问题？MySQL的事务隔离级别了解吗？
MySQL的四种隔离级别如下：
- 未提交读(READ UNCOMMITTED)
这就是上面`隔离性`的意外情况，这个隔离级别下，其他事务可以看到本事务没有提交的的部分修改，因此造成了脏读问题(读取了其他事务未提交的部分，而之后该事务进行了回滚)

这个级别的性能没有足够大的优势，但是又有很多的问题，因此很少使用

- 已提交读(READ COMMITTED)
其他事务只能读取到本事务已经提交的部分，这个隔离级别有`不可重复读`的问题，在同一个事务内的两次读取，拿到的结果竟然不一样，因为另一个事务在这期间对数据进行了修改。
- 可重复度(REPEATEABLE READ)
可重复度隔离级别解决了上面不可重复读的问题，但是会造成新的问题，`幻读`。当你读取id>10的数据行时，对涉及到的所有行加上了读锁，此时例外一个事务新插入了一条id=11的数据，因为新插入的，所以不会触发上面的锁排斥，那么进行本事务进行下一次的查询会发现有一条id=11的数据，而上次的查询操作并没有获取到，再进行插入就会有主键冲突的问题。
- 可串行化(SERIALIZABLE)
这是最高的隔离级别，可以解决上面提到的所有问题，因为他强制将所有的操作串行化执行，这会导致并发性能急速下降，因此不是很常用

### 5. InnoDB使用的是哪种隔离级别？
InnoDB默认使用的是`可重复读隔离级别`

### 6. 对MySQL的锁了解吗？
当数据库有并发事务的时候，可能会产生数据的不一致，，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。

### 7. MySQL都有哪些锁？

- 共享锁(Shared)：又叫读锁，简称S锁，当用户要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个
- 排它锁(Exclusive)：又叫写锁,简称X锁，当用户要进行数据的写入时，对数据加上排它锁，排它锁只可以加一个，他和其他的排它锁，共享锁都互斥

规定：
- 一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁
- 一个事务对数据对象A加了S锁，可以对A进行读取操作，但不能进行更新操作。加锁期间其他事务能对A加S锁，但不能加X锁

— 乐观锁(Optimistic Lock)：假设不会发生并发冲突，只在提交操作时检查是否违法了数据完整性。乐观锁不能解决脏读的问题。

用数据版本(Version)记录机制实现，这是乐观锁最常用的一种实现方式。即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的"version"字段来实现。当读取数据时，将对应的记录将version字段的值一同读出，数据每更新新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相同，则予以更新，否则认为是国企数据

- 悲观锁(Pessimistic)：假定会发生冲突，屏蔽一切可能违反数据完整性的操作。所以悲观锁需要消耗较多的时间。

悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。












